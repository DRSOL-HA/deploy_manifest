def REPOS = [
  // 모노레포 하나(WebBoard-Service)에서 서비스별 컨텍스트 빌드
  'user-service': 'git@github.com:DRSOL-HA/WebBoard-Service.git',
  'file-service': 'git@github.com:DRSOL-HA/WebBoard-Service.git',
  'post-service': 'git@github.com:DRSOL-HA/WebBoard-Service.git',
  'frontend'    : 'git@github.com:DRSOL-HA/WebBoard-Service.git',
  'nginx'       : 'git@github.com:DRSOL-HA/WebBoard-Service.git',
]

pipeline {
  agent {
    kubernetes {
      yaml """
apiVersion: v1
kind: Pod
metadata:
  labels:
    jenkins: buildkit
spec:
  serviceAccountName: jenkins
  containers:
  - name: buildctl
    image: moby/buildkit:rootless
    command: ["cat"]
    tty: true
    volumeMounts:
    - { name: tls, mountPath: /tls, readOnly: true }
    - { name: workspace-volume, mountPath: /home/jenkins/agent, readOnly: false }

  - name: git
    image: alpine/git:2.45.2
    command: ["cat"]
    tty: true
    securityContext: { runAsUser: 0, runAsGroup: 0 }
    volumeMounts:
    - { name: workspace-volume, mountPath: /home/jenkins/agent, readOnly: false }

  - name: yq
    image: ghcr.io/mikefarah/yq:4
    command: ["cat"]
    tty: true
    securityContext: { runAsUser: 0, runAsGroup: 0 }
    volumeMounts:
    - { name: workspace-volume, mountPath: /home/jenkins/agent, readOnly: false }

  volumes:
  - name: tls
    secret:
      secretName: buildkit-client-tls
  - name: workspace-volume
    emptyDir: {}
"""
    }
  }

  parameters {
    choice(
      name: 'SERVICE',
      choices: 'user-service\nfile-service\npost-service\nfrontend\nnginx',
      description: '빌드/배포할 서비스'
    )
    string(name: 'BRANCH', defaultValue: 'main', description: '서비스 코드 브랜치')
    string(name: 'IMAGE_TAG', defaultValue: '', description: '비우면 v<빌드번호>')
  }

  options {
    disableConcurrentBuilds()
    skipDefaultCheckout(true)
  }

  environment {
    REGISTRY      = 'ghcr.io/drsol-ha'   // 소문자 권장(OCI)
    BUILDKIT_ADDR = 'tcp://buildkitd.buildkit.svc.cluster.local:1234'
  }

  stages {
    stage('Prepare environment') {
      steps {
        script {
          env.IMAGE_TAG = (params.IMAGE_TAG?.trim()) ? params.IMAGE_TAG.trim() : "v${env.BUILD_NUMBER}"
          echo "Image tag set to: ${env.IMAGE_TAG}"
        }
      }
    }

    stage('Checkout service code') {
      steps {
        container('git') {
          script {
            env.REPO_HTTPS = REPOS[params.SERVICE].replace('git@github.com:', 'https://github.com/')
          }
          withEnv(["BRANCH=${params.BRANCH}"]) {
            withCredentials([usernamePassword(
              credentialsId: '2ebc3d3c-d09f-4180-8a21-74f50626cd2b', // GitHub PAT (Username with password)
              usernameVariable: 'GH_USER',
              passwordVariable: 'GH_PAT'
            )]) {
              sh '''
                set -euxo pipefail
                rm -rf src && mkdir -p src

                # 권한 체크
                { set +x; } 2>/dev/null
                git -c http.extraheader="AUTHORIZATION: Basic $(printf '%s:%s' "$GH_USER" "$GH_PAT" | base64 | tr -d '\n')" \
                  ls-remote --heads "$REPO_HTTPS" >/dev/null
                { set -x; } 2>/dev/null || true

                # clone
                { set +x; } 2>/dev/null
                git -c http.extraheader="AUTHORIZATION: Basic $(printf '%s:%s' "$GH_USER" "$GH_PAT" | base64 | tr -d '\n')" \
                  clone --depth=1 -b "$BRANCH" "$REPO_HTTPS" src/app
                { set -x; } 2>/dev/null || true
              '''
            }
          }
        }
      }
    }

    stage('Resolve build context') {
      steps {
        container('git') {
          withEnv(["SERVICE=${params.SERVICE}"]) {
            sh '''
              set -euxo pipefail
              # SERVICE 힌트 (xxx-service -> xxx)
              HINT="$(printf '%s' "$SERVICE" | sed 's/-service$//')"

              FOUND=""
              for c in \
                "services/${SERVICE}" \
                "services/${HINT}" \
                "apps/${SERVICE}" \
                "apps/${HINT}" \
                "packages/${SERVICE}" \
                "packages/${HINT}" \
                "${SERVICE}" \
                "${HINT}" \
                "apps/${SERVICE}/app" \
                "apps/${HINT}/app" \
                "services/${SERVICE}/app" \
                "services/${HINT}/app"
              do
                if [ -d "src/app/$c" ] && ls "src/app/$c"/Dockerfile* >/dev/null 2>&1; then
                  FOUND="$c"
                  break
                fi
              done

              if [ -z "$FOUND" ]; then
                echo "ERROR: '${SERVICE}'의 Dockerfile 경로를 찾지 못했습니다."
                echo "다음 후보 경로를 확인하세요(하나에 Dockerfile* 필요):"
                printf ' - %s\n' \
                  "services/${SERVICE}" "services/${HINT}" \
                  "apps/${SERVICE}"     "apps/${HINT}" \
                  "packages/${SERVICE}" "packages/${HINT}" \
                  "${SERVICE}"          "${HINT}" \
                  "apps/${SERVICE}/app" "apps/${HINT}/app" \
                  "services/${SERVICE}/app" "services/${HINT}/app"
                exit 2
              fi

              echo "Detected build context: $FOUND"
              echo "$FOUND" > .build_context_path
            '''
          }
        }
      }
    }

    stage('Build & Push image') {
      steps {
        container('buildctl') {
          withCredentials([usernamePassword(credentialsId: 'ghcr',
            usernameVariable: 'GHCR_USER', passwordVariable: 'GHCR_PAT')]) {
            withEnv(["SERVICE=${params.SERVICE}"]) {
              sh '''
                set -euxo pipefail

                CONTEXT_PATH="$(cat .build_context_path)"
                IMAGE_NAME="${REGISTRY}/board-${SERVICE}"

                # 메타파일 경로(절대경로로 지정)
                META="${WORKSPACE:-$PWD}/.buildmeta.json"

                export HOME="${WORKSPACE:-$PWD}"
                export DOCKER_CONFIG="$HOME/.docker"
                mkdir -p "$DOCKER_CONFIG"

                # docker config.json 생성 (secret 로그 숨김)
                { set +x; } 2>/dev/null
                AUTH=$(printf '%s:%s' "$GHCR_USER" "$GHCR_PAT" | base64 | tr -d '\n')
                cat > "$DOCKER_CONFIG/config.json" <<EOF
                { "auths": { "ghcr.io": { "auth": "$AUTH" } } }
                EOF
                { set -x; } 2>/dev/null || true

                # 디버그
                which buildctl || true
                buildctl --version || true

                # Build & Push (+ 메타파일)
                buildctl --addr "$BUILDKIT_ADDR" \
                  --tlscacert /tls/ca.crt --tlscert /tls/client.crt --tlskey /tls/client.key \
                  build --frontend=dockerfile.v0 --progress=plain \
                  --local context="src/app/${CONTEXT_PATH}" \
                  --local dockerfile="src/app/${CONTEXT_PATH}" \
                  --output type=image,name="$IMAGE_NAME:$IMAGE_TAG",push=true \
                  --metadata-file "$META" || { echo "buildctl failed"; exit 10; }

                # 메타파일 생성 확인(없으면 다음 스테이지에서 레지스트리 조회로 보완)
                if [ -s "$META" ]; then
                  echo "Build metadata saved: $META"
                  head -c 200 "$META" || true
                else
                  echo "WARN: build metadata not created: $META (fallback to registry HEAD in next stage)"
                fi
              '''
            }
          }
        }
      }
    }

    stage('Extract digest') {
      steps {
        container('git') {
          withCredentials([usernamePassword(credentialsId: 'ghcr',
            usernameVariable: 'U', passwordVariable: 'T')]) {
            withEnv(["SERVICE=${params.SERVICE}"]) {
              sh '''
                set -euxo pipefail
                META="${WORKSPACE:-$PWD}/.buildmeta.json"
                OUT="${WORKSPACE:-$PWD}/.image_digest"
                IMG_PATH="drsol-ha/board-${SERVICE}"
                TAG="${IMAGE_TAG}"

                # 우선 메타에서 시도(jq 있으면 정확 키, 없으면 grep)
                apk add --no-cache jq curl >/dev/null 2>&1 || true
                DIGEST=""

                if [ -s "$META" ]; then
                  if command -v jq >/dev/null 2>&1; then
                    DIGEST=$(jq -r '."containerimage.digest" // .containerimage.digest // ."containerimage.descriptor".digest // empty' "$META" || true)
                  fi
                  if [ -z "$DIGEST" ]; then
                    DIGEST=$(grep -oE 'sha256:[0-9a-f]{64}' "$META" | head -1 || true)
                  fi
                fi

                # 메타에서 못 찾으면 GHCR HEAD로 조회 (Basic → Bearer 순서)
                if [ -z "$DIGEST" ]; then
                  URL="https://ghcr.io/v2/${IMG_PATH}/manifests/${TAG}"

                  # v2s2 manifest로 강제
                  HDR_ACCEPT="Accept: application/vnd.docker.distribution.manifest.v2+json"

                  # Basic
                  DIGEST=$(curl -sIL -u "$U:$T" -H "$HDR_ACCEPT" "$URL" \
                    | awk -F': ' 'tolower($1)=="docker-content-digest" {gsub("\r","",$2); print $2}' | tail -1 || true)

                  # Bearer fallback
                  if [ -z "$DIGEST" ]; then
                    DIGEST=$(curl -sIL -H "Authorization: Bearer $T" -H "$HDR_ACCEPT" "$URL" \
                      | awk -F': ' 'tolower($1)=="docker-content-digest" {gsub("\r","",$2); print $2}' | tail -1 || true)
                  fi
                fi

                if [ -z "$DIGEST" ]; then
                  echo "ERROR: failed to obtain digest (meta & registry both failed)"; exit 11
                fi

                echo "$DIGEST" > "$OUT"
                echo "Image digest: $DIGEST"
              '''
            }
          }
        }
      }
    }

    stage('Bump manifest (pin by digest)') {
      steps {
        // deploy_manifest clone (HTTPS + PAT)
        container('git') {
          withCredentials([usernamePassword(
            credentialsId: '2ebc3d3c-d09f-4180-8a21-74f50626cd2b',
            usernameVariable: 'GH_USER',
            passwordVariable: 'GH_PAT'
          )]) {
            sh '''
              set -euxo pipefail
              rm -rf manifest && mkdir -p manifest
              cd manifest
              { set +x; } 2>/dev/null
              git -c http.extraheader="AUTHORIZATION: Basic $(printf '%s:%s' "$GH_USER" "$GH_PAT" | base64 | tr -d '\n')" \
                clone --depth=1 https://github.com/DRSOL-HA/deploy_manifest.git repo
              { set -x; } 2>/dev/null || true
              cd repo
              git config user.name  "jenkins"
              git config user.email "ci@drsol-ha.local"
            '''
          }
        }

        // yq로 digest 핀 (newTag 제거)
        container('yq') {
          withEnv(["SERVICE=${params.SERVICE}"]) {
            sh '''
              set -euxo pipefail
              cd manifest/repo
              FILE="apps/board/kustomization.yaml"
              [ -f "$FILE" ] || FILE="apps/webboard/kustomization.yaml"
              if [ ! -f "$FILE" ]; then
                echo "ERROR: kustomization.yaml 파일을 찾지 못했습니다. (apps/board 또는 apps/webboard)"
                exit 3
              fi

              export IMG_LOWER="ghcr.io/drsol-ha/board-${SERVICE}"
              export IMG_UPPER="ghcr.io/DRSOL-HA/board-${SERVICE}"
              DIGEST="$(cat "$WORKSPACE/.image_digest")"
              if [ -z "$DIGEST" ]; then
                echo "ERROR: digest file missing: $WORKSPACE/.image_digest"; exit 8
              fi

              yq -i '
                (.images[] | select((.name == strenv(IMG_LOWER)) or (.name == strenv(IMG_UPPER))))
                |= (.digest = strenv(DIGEST)) |
                del(.images[] | select((.name == strenv(IMG_LOWER)) or (.name == strenv(IMG_UPPER))).newTag)
              ' "$FILE"

              echo "Pinned image to digest: $DIGEST"
              yq '.images[] | select(.name == strenv(IMG_LOWER) or .name == strenv(IMG_UPPER))' "$FILE"
            '''
          }
        }

        // commit & push
        container('git') {
          withCredentials([usernamePassword(
            credentialsId: '2ebc3d3c-d09f-4180-8a21-74f50626cd2b',
            usernameVariable: 'GH_USER',
            passwordVariable: 'GH_PAT'
          )]) {
            sh '''
              set -euxo pipefail
              cd manifest/repo
              if git diff --quiet -- .; then
                echo "No manifest changes to commit."
              else
                SHORT=$(cut -c8-19 "$WORKSPACE/.image_digest" 2>/dev/null || echo "")
                git add -A
                git commit -m "ci: pin board-${SERVICE} to digest ${SHORT:-$(cat "$WORKSPACE/.image_digest")}"
                { set +x; } 2>/dev/null
                git -c http.extraheader="AUTHORIZATION: Basic $(printf '%s:%s' "$GH_USER" "$GH_PAT" | base64 | tr -d '\n')" \
                  push origin HEAD:main
                { set -x; } 2>/dev/null || true
              fi
            '''
          }
        }
      }
    }
  }
}
